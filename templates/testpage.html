<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Server Test Page</title>

    <style>
      .debugWrapper {
        padding: 1rem;
        background-color: #f1f1f1;
      }
      .formWrapper {
        margin-top: 1rem;
      }
    </style>
  </head>
  <body>
    <h1>Connection Test Page</h1>
    <div id="debugWrapper" class="debugWrapper"></div>

    <div class="formWrapper">
      <input type="text" id="receiver" placeholder="Odbiorca" />
      <input type="text" id="content" placeholder="Wiadomość" />
      <button id="send">Send</button>
    </div>

    <script>
      const setDebug = (content) => {
        const p = document.createElement("pre");
        p.innerText = content;
        document.getElementById("debugWrapper").append(p);
      };

      class RSAConnect {
        gcd = (a, b) => {
          while (b !== 0) {
            const temp = b;
            b = a % b;
            a = temp;
          }
          return a;
        };

        modularInverse = (e, fi) => {
          let [old_r, r] = [e, fi];
          let [old_s, s] = [1, 0];
          let [old_t, t] = [0, 1];

          while (r !== 0) {
            const quotient = Math.floor(old_r / r);
            [old_r, r] = [r, old_r - quotient * r];
            [old_s, s] = [s, old_s - quotient * s];
            [old_t, t] = [t, old_t - quotient * t];
          }

          return (old_s + fi) % fi;
        };

        getKeyPair = (P, Q, E) => {
          const N = P * Q;
          const Fi = (P - 1) * (Q - 1);
          const D = this.modularInverse(E, Fi);
          return [N, D];
        };


        encodePublicKey(n, e) {
          let nStr = n.toString();
          let eStr = e.toString();
          const maxLength = Math.max(nStr.length, eStr.length);
          nStr = nStr.padStart(maxLength, "0");
          eStr = eStr.padStart(maxLength, "0");
          return parseInt(nStr + eStr, 10);
        }

        decodePublicKey(encodedNum) {
          const encodedStr = encodedNum.toString();
          const halfLength = encodedStr.length / 2;
          const n = parseInt(encodedStr.slice(0, halfLength), 10);
          const e = parseInt(encodedStr.slice(halfLength), 10);
          return [n, e];
        }

        parseJwt = (token) => {
          const base64Url = token.split(".")[1];
          const base64 = base64Url.replace(/-/g, "+").replace(/_/g, "/");
          const jsonPayload = decodeURIComponent(
            atob(base64)
              .split("")
              .map((c) => "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2))
              .join("")
          );

          return JSON.parse(jsonPayload);
        };

        modExp = (base, exponent, modulus) => {
          let result = 1;
          base = base % modulus;
          while (exponent > 0) {
            if (exponent % 2 === 1) {
              result = (result * base) % modulus;
            }
            exponent = Math.floor(exponent / 2);
            base = (base * base) % modulus;
          }
          return result;
        };

        // Function to convert decimal to hex with padding to a fixed length
        decimalToHex = (decimal, length) => {
          return decimal.toString(16).padStart(length, "0");
        };

       //  po staremu - szyfrowanie znak po znaku oddzielone :
        encrypt = (text, e, n) => {
          const maxHexLength = Math.ceil(Math.log2(n) / 4); // Each hex digit represents 4 bits
          return text
            .split("")
            .map((char) => {
              const asciiCode = char.charCodeAt(0);
              const encryptedChar = this.modExp(asciiCode, e, n);
              return this.decimalToHex(encryptedChar, maxHexLength); // Fixed-length hex
            })
            .join(":"); // Join with colons
        };

        intToNBitString(value, n) {
          let binaryString = (value & ((1 << n) - 1)).toString(2);
          return binaryString.padStart(n, "0");
        }

        bitStringToInt(bitString) {
          return parseInt(bitString, 2);
        }

        binaryStringToText(binaryString) {
          let text = "";
          let byte;
          let charCode;
          console.log("decoded");

          for (let i = 0; i < binaryString.length; i += 8) {
            byte = binaryString.slice(i, i + 8);
            if (this.isAllZeroes(byte)) {
              console.log("ALL ZEROS");
              break;
            }
            charCode = this.bitStringToInt(byte);
            console.log(charCode, String.fromCharCode(charCode));
            text += String.fromCharCode(charCode);
          }
          return text;
        }

        textToBinaryString(text) {
          let binaryString = "";
          for (let i = 0; i < text.length; i++) {
            binaryString += this.intToNBitString(text.charCodeAt(i), 8);
          }
          return binaryString;
        }


        isAllZeroes(str) {
          return /^0+$/.test(str);
        }


        // po nowemu - podział na chunki
        decrypt(encryptedText, d, n) {
          d = parseInt(d);
          n = parseInt(n);

          let chunkLength = Math.ceil(Math.log2(n));
          let binaryEncrypted = this.textToBinaryString(encryptedText);
          let decryptedBinary = "";
          let chunkValue;
          let currentChunk, decodedValue, decodedBinary;

          // dotąd ok

          console.log(binaryEncrypted);

          console.log("ChunkLength", chunkLength);

          while (binaryEncrypted.length > 0) {
            console.log("---");
            currentChunk = binaryEncrypted.slice(0, chunkLength);
            binaryEncrypted = binaryEncrypted.slice(chunkLength);
            console.log(currentChunk);

            chunkValue = this.bitStringToInt(currentChunk);
            console.log(chunkValue, d, n);

            decodedValue = this.modExp(chunkValue, d, n);
            console.log(decodedValue);

            decodedBinary = this.intToNBitString(decodedValue, chunkLength);
            console.log(decodedBinary);
            decryptedBinary += decodedBinary;
          }

          // odtąd ok

          const decrypted = this.binaryStringToText(decryptedBinary);
          console.log("Decrypted length: ", decrypted.length);
          return decrypted;
        }

      }

      const RSA = new RSAConnect();

      const get = async (url, token) => {
        const headers = {
          "Content-Type": "application/json",
        };
        if (token) {
          headers["Authorization"] = `Bearer ${token}`;
        }

        const result = await fetch(url, {
          method: "GET",
          headers,
        })
          .then((response) => {
            if (!response.ok) {
              throw new Error("GET failed: " + response.statusText);
            }
            return response.json();
          })
          .catch((error) => {
            console.error("Error:", error);
            return null;
          });

        setDebug(`# GET <${url}>`);
        setDebug(`# GET RESULT: ${JSON.stringify(result)}`);

        return result;
      };

      const post = async (url, data, token) => {
        const headers = {
          "Content-Type": "application/json",
        };
        if (token) {
          headers["Authorization"] = `Bearer ${token}`;
        }

        const result = await fetch(url, {
          method: "POST",
          headers,
          body: JSON.stringify(data),
        })
          .then((response) => {
            if (!response.ok) {
              throw new Error("Login failed: " + response.statusText);
            }
            return response.json();
          })
          .catch((error) => {
            console.error("Error:", error);
            return null;
          });

        setDebug(`# POST <${url}>, ${JSON.stringify(data)}`);
        setDebug(`# POST RESULT: ${JSON.stringify(result)}`);

        return result;
      };

      class Client {
        token = null;

        register = async (username, password) => {
          const result = await post("/auth/register", {
            username,
            password,
          });

          return result;
        };

        login = async (username, password, clientPub) => {
          const result = await post("/auth/login", {
            username,
            password,
            clientPub,
          });

          return result;
        };

        sendMessage = async (receiver, content, token) => {
          const result = await post(
            "/message/conversations",
            {
              receiver,
              content,
            },
            token
          );

          return result;
        };

        users = async (token) => {
          return await get(`/users`, token);
        };

        conversations = async (token) => {
          return await get(`/message/conversations`, token);
        };

        conversationsWithUser = async (username, token) => {
          return await get(`/message/conversations/${username}`, token);
        };
      }

      /// test scenario: register, login, post message, get message,

      const testScenario = async () => {
        setDebug(`// TEST CONNECTION`);

        const client = new Client();
        const username = `michael.jack.${Math.random()}`;
        const messageText = "Hello my friend! Smacznej kawusi! Jest ok!";
        const passwordhash =
          "176d3c9c166b319d8b5470b336d7582861e347677770731a772135557ab2b7bc";
        const clientP = 61;
        const clientQ = 41;
        const clientE = 17;
        const [clientN, clientD] = RSA.getKeyPair(clientP, clientQ, clientE);

        setDebug(`clientP: ${clientP}`);
        setDebug(`clientQ: ${clientQ}`);

        setDebug(`clientE: ${clientE}`);
        setDebug(`clientN: ${clientN}`);

        const registerResult = await client.register(username, passwordhash);
        setDebug(`Register result: ${JSON.stringify(registerResult ?? "")}`);

        const loginResult = await client.login(
          username,
          passwordhash,
          RSA.encodePublicKey(clientN, clientE)
        );
        setDebug(`Login result: ${JSON.stringify(loginResult ?? "")}`);

        const JWToken = loginResult.token;
        if (!JWToken) {
          setDebug(`Empty JWT - exit.`);
          return;
        }

        const users = await client.users(JWToken);
        setDebug(`Users list: ${JSON.stringify(users ?? "")}`);

        const tokenContent = RSA.parseJwt(JWToken);
        setDebug(`JWT content: ${JSON.stringify(tokenContent ?? "")}`);

        const serverPub = tokenContent.serverPub;
        const [serverN, serverE] = RSA.decodePublicKey(serverPub);
        setDebug(`serverE: ${serverE}`);
        setDebug(`serverN: ${serverN}`);

        const conversations = await client.conversations(JWToken);
        setDebug(`Conversations list: ${JSON.stringify(conversations ?? "")}`);

        const firstUserUsername = users.users[0].username;

        const conversationsWithFirstUser = await client.conversationsWithUser(
          firstUserUsername,
          JWToken
        );
        setDebug(
          `ConversationsWithFirstUser: ${JSON.stringify(
            conversationsWithFirstUser ?? ""
          )}`
        );

        const encryptedMessage = RSA.encrypt(messageText, serverE, serverN);
        setDebug(`Message text: ${messageText}`);
        setDebug(
          `Message encrypted with server public key: ${encryptedMessage}`
        );

        const sendMessage = await client.sendMessage(
          firstUserUsername,
          encryptedMessage,
          JWToken
        );
        setDebug(`SendMessage result: ${JSON.stringify(sendMessage ?? "")}`);

        const conversationsAfter = await client.conversations(JWToken);
        setDebug(
          `Conversations list: ${JSON.stringify(conversationsAfter ?? "")}`
        );

        const conversationsWithFirstUserAfter =
          await client.conversationsWithUser(firstUserUsername, JWToken);
        setDebug(
          `ConversationsWithFirstUser: ${JSON.stringify(
            conversationsWithFirstUserAfter ?? ""
          )}`
        );

        const receivedMessage =
          conversationsWithFirstUserAfter.messages[0].content;
        setDebug(`Message encrypted by server: ${receivedMessage}`);

        const decryptedMessage = RSA.decrypt(receivedMessage, clientD, clientN);
        setDebug(
          `Message decrypted with client private key: ${decryptedMessage}`
        );

        console.log(
          "Original length: ",
          conversationsWithFirstUserAfter.messages[0].contentPlainText.length
        );

        const sendButton = document
          .getElementById("send")
          .addEventListener("click", async () => {
            const receiver = document.getElementById("receiver").value;
            const content = document.getElementById("content").value;
            const encryptedMessage = RSA.encrypt(content, serverE, serverN);

            const sendMessage = await client.sendMessage(
              receiver,
              encryptedMessage,
              JWToken
            );
            setDebug(
              `SendMessage result: ${JSON.stringify(sendMessage ?? "")}`
            );

            const conversationAfter = await client.conversationsWithUser(
              receiver,
              JWToken
            );
            setDebug(
              `Conversation: ${JSON.stringify(conversationAfter ?? "")}`
            );

            document.getElementById("receiver").value = "";
            document.getElementById("content").value = "";
          });
      };
      testScenario();
    </script>
  </body>
</html>
